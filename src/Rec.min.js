/** @license React v16.4.1 * react.development.js * * Copyright (c) 2013-present, Facebook, Inc. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. */ 'use strict'; (function (global, factory) {  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  typeof define === 'function' && define.amd ? define(factory) :  (global.React = factory()); }(this, (function () { 'use strict'; /* object-assign (c) Sindre Sorhus @license MIT */ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols; var hasOwnProperty = Object.prototype.hasOwnProperty; var propIsEnumerable = Object.prototype.propertyIsEnumerable; function toObject(val) {  if (val === null || val === undefined) {   throw new TypeError('Object.assign cannot be called with null or undefined');  }  return Object(val); } function shouldUseNative() {  try {   if (!Object.assign) {    return false;   }   // Detect buggy property enumeration order in older V8 versions.   // https://bugs.chromium.org/p/v8/issues/detail?id=4118   var test1 = new String('abc'); // eslint-disable-line no-new-wrappers   test1[5] = 'de';   if (Object.getOwnPropertyNames(test1)[0] === '5') {    return false;   }   // https://bugs.chromium.org/p/v8/issues/detail?id=3056   var test2 = {};   for (var i = 0; i < 10; i++) {    test2['_' + String.fromCharCode(i)] = i;   }   var order2 = Object.getOwnPropertyNames(test2).map(function (n) {    return test2[n];   });   if (order2.join('') !== '0123456789') {    return false;   }   // https://bugs.chromium.org/p/v8/issues/detail?id=3056   var test3 = {};   'abcdefghijklmnopqrst'.split('').forEach(function (letter) {    test3[letter] = letter;   });   if (Object.keys(Object.assign({}, test3)).join('') !==     'abcdefghijklmnopqrst') {    return false;   }   return true;  } catch (err) {   // We don't expect any of the above to throw, but better to be safe.   return false;  } } var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {  var from;  var to = toObject(target);  var symbols;  for (var s = 1; s < arguments.length; s++) {   from = Object(arguments[s]);   for (var key in from) {    if (hasOwnProperty.call(from, key)) {     to[key] = from[key];    }   }   if (getOwnPropertySymbols) {    symbols = getOwnPropertySymbols(from);    for (var i = 0; i < symbols.length; i++) {     if (propIsEnumerable.call(from, symbols[i])) {      to[symbols[i]] = from[symbols[i]];     }    }   }  }  return to; }; // TODO: this is special because it gets imported during build. var ReactVersion = '16.4.1'; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol // nor polyfill, then a plain number is used for performance. var hasSymbol = typeof Symbol === 'function' && Symbol.for; var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7; var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca; var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb; var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc; var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2; var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd; var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf; var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0; var REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for('react.timeout') : 0xead1; var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator; var FAUX_ITERATOR_SYMBOL = '@@iterator'; function getIteratorFn(maybeIterable) { if (maybeIterable === null || typeof maybeIterable === 'undefined') { return null; } var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]; if (typeof maybeIterator === 'function') { return maybeIterator; } return null; }